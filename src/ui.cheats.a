;license:MIT
;(c) 2018-9 by 4am
;
; cheat-related UI functions
;
; Public functions:
; - ToggleCheat
; - BuildUILine1WithNoDots
; - BuildCheatLine1
; - BuildCheatLine2
;

ToggleCheat
; in:    none
; out:   all registers clobbered
;        X = 0, Z = 1 (guaranteed by pref_set)
         lda   gCheatsEnabled
         eor   #$80
         sta   gCheatsEnabled
         beq   +
         lda   #$B1
         +HIDE_NEXT_2_BYTES
+        lda   #$B0
         sta   @val
         jsr   pref_set
         !word kCheat
         !word @pref
         rts
@pref    !byte 1
@val     !byte $FD

BuildUILine1And2
; in:    gGameToLaunch = game index, or #$FF if no game selected
;        C set = print block cursor after game title and print dots to
;                highlight matching characters
;        C clear = don't print either of those things
;        UILine1 and UILine2 each contain a 40-character buffer (not length-prefixed) to print
         php
         bcc   +                     ; set up cursor printing if caller wanted that
         lda   #$7F
         +HIDE_NEXT_2_BYTES
+
         lda   #" "
         sta   @printCursor+1

         ldy   #39                   ; copy instructions to line 2
-        lda   Instructions,y
         sta   UILine2,y
         dey
         bpl   -

         ldx   gGameToLaunch
         cpx   #$FF                  ; if no game, we're done with the bottom line
         beq   @doneWithLine2

         +LDADDR gGamesListStore
         jsr   okvs_nth
         +STAY +

         jsr   okvs_get
         !word gGamesListStore
+        !word $FDFD
         +STAY SRC                   ; (SRC) -> game title (in OKVS)

         ldy   #0                    ; copy game title into search bar buffer
         lda   (SRC),y
         sta   SAVE                  ; game title length
         inc   SAVE
-        iny
         cpy   SAVE
         bcc   @printTitleChar
         beq   @printCursor
         lda   #" "
         +HIDE_NEXT_2_BYTES
@printCursor
         lda   #$FD                  ; SMC
         +HIDE_NEXT_2_BYTES
@printTitleChar
         lda   (SRC),y               ; copy game title to search UI
         sta   UILine2,y
         cpy   #MaxInputLength+1
         bcc   -
         ldx   #8
-        lda   ReturnToPlay,x        ; replace games count with 'to play' label
         sta   UI_ToPlay,x
         dex
         bpl   -

@doneWithLine2
         ldx   gGameToLaunch
         ldy   gCheatsAvailable,x
         cpx   #$FF
         bne   +
         ldy   #.kCheatsEnabled
+
         ldx   #40
         lda   #$00                  ; horizontal bar
-        sta   UILine1-1,x           ; first, reset entire line to solid bar
         dex
         bne   -

         bit   gCheatsEnabled
         bpl   @maybeDrawDots        ; if no cheats, we don't need any curves on this line

         lda   .kCheatDescriptionLo,y
         sta   PTR
         lda   .kCheatDescriptionHi,y
         sta   PTR+1
                                     ; (PTR) -> length-prefixed cheat description
         ldy   #0
         lda   (PTR),y               ; A = length of cheat description
         clc
         adc   #4                    ; extra padding (2 on each side)
         sta   @len
         lda   #40
         sec
         sbc   @len
         lsr
         tax
         lda   #$09                  ; rounded bottom-right character
         sta   UILine1,x
         ldy   #1                    ; fill the proper width with spaces
         lda   #$20                  ; space character
-        inx
         sta   UILine1,x
         iny
@len=*+1
         cpy   #$FD                  ; SMC
         bne   -
         lda   #$08                  ; rounded bottom-left character
         sta   UILine1,x

@maybeDrawDots
         plp
         bcc   @doneHighlight

         ldx   #0
         ldy   #0
@dotloop
         iny
         lda   (SRC),y               ; (SRC) still points to game title
         +LOW_ASCII_TO_LOWER
         cmp   InputBuffer,x
         bne   +
         lda   #$11                  ; dot character
         sta   UILine1,y
         inx
         cpx   InputLength           ; if input buffer is exhausted, we're done
         beq   @doneHighlight
+        inc   HTAB
         cpy   SAVE                  ; if game name is exhausted, we're done
         bne   @dotloop
@doneHighlight
         rts

BuildCheatLine1
; in:    gGameToLaunch = game index, or #$FF if no game is selected
; out:   gPathname contains length-prefixed string to print centered
;        all registers clobbered
;        PTR clobbered
         ldx   gGameToLaunch
         ldy   gCheatsAvailable,x
         cpx   #$FF
         bne   +
         ldy   #.kCheatsEnabled
+
         ldx   #39                   ; reset gPathname+2 to gPathname+41 to
         lda   #$00                  ; horizontal bar character
-        sta   gPathname+1,x
         dex
         bne   -

         lda   #$06                  ; gPathname+1 = top-left rounded corner character
         sta   gPathname+1

         lda   .kCheatDescriptionLo,y
         sta   PTR
         lda   .kCheatDescriptionHi,y
         sta   PTR+1
                                     ; (PTR) -> length-prefixed cheat description
         ldy   #0
         lda   (PTR),y               ; A = length of cheat description
         clc
         adc   #4                    ; extra padding (2 on each side)
         sta   gPathname             ; gPathname = length
         tax
         lda   #$07                  ; gPathname+length = top-right rounded corner character
         sta   gPathname,x
         rts

BuildCheatLine2
; in:    gGameToLaunch = game index, or #$FF if no game is selected
; out:   gPathname contains length-prefixed string to print centered
;        all registers clobbered
;        PTR clobbered
;        SAVE clobbered
         ldx   gGameToLaunch
         ldy   gCheatsAvailable,x
         cpx   #$FF
         bne   +
         ldy   #.kCheatsEnabled
+        lda   .kCheatDescriptionLo,y
         sta   SAVE
         lda   .kCheatDescriptionHi,y
         sta   SAVE+1
                                     ; (SAVE) -> length-prefixed cheat description
         +LDADDR .sCheatDescriptionPrefix
         jsr   SetPath
         +LDAY SAVE
         jsr   AddToPath
         +LDADDR .sCheatDescriptionSuffix
         jmp   AddToPath

.kCheatsEnabled = 3                  ; index of 'cheats enabled' string in following table
.kCheatDescriptionLo
         !byte <.sNoCheats
         !byte <.sInfiniteLives
         !byte <.sInfiniteLivesAndWeapons
         !byte <.sCheatsEnabled
.kCheatDescriptionHi
         !byte >.sNoCheats
         !byte >.sInfiniteLives
         !byte >.sInfiniteLivesAndWeapons
         !byte >.sCheatsEnabled
.sNoCheats
         !byte 8
         !text "no cheat"
.sInfiniteLives
         !byte 18
         !byte $16        ; bolt
         !text " "
         !text "infinite lives"
         !text " "
         !byte $16        ; bolt
.sInfiniteLivesAndWeapons
         !byte 28
         !byte $16        ; bolt
         !text " "
         !text "infinite lives & weapons"
         !text " "
         !byte $16        ; bolt
.sCheatsEnabled
         !byte 18
         !byte $16        ; bolt
         !text " "
         !text "cheats enabled"
         !text " "
         !byte $16        ; bolt
.sCheatDescriptionPrefix
         !byte 2
         !byte $03        ; vertical line
         !text " "
.sCheatDescriptionSuffix
         !byte 2
         !text " "
         !byte $03        ; vertical line
