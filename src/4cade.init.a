;license:MIT
;(c) 2018 by 4am
;

; this file is included directly and is run from $2000/main as soon as the .SYSTEM file is loaded

         sta   $C00E                 ; 40-column
         sta   $C00C
         sta   $C004
         sta   $C002
         sta   $C000
         jsr   $FB2F
         jsr   $FC58
         jsr   Has64K                ; check for 64K (required)
         bcs   @no64K
         jsr   DisableAccelerator    ; set to 1 MHz
         jsr   Has128K               ; check for 128K (absence is OK, we just filter out some games)
         ror   MachineStatus
         jsr   HasJoystick           ; check for joystick (absence is OK, we just filter out some games)
         ror   MachineStatus         ; now bit 6 = 1 if 128K
                                     ;     bit 7 = 1 if joystick

         jsr   init                  ; initialize ProRWTS2 (bye bye ProDOS)
         +READ_RAM1_WRITE_RAM1
         ldx   #$00                  ; relocate rest of program to RAM bank 1 in language card
@FM      lda   FirstMover,x
         sta   $D000,x
         inx
         bne   @FM
         lda   @FM+2
         cmp   #>LastMover
         bcs   +
         inc   @FM+2
         inc   @FM+5
         bne   @FM
+
         jmp   OneTimeSetup

@no64K
         ldy   #@no64Klen
-        lda   @s_no64K,y
         sta   $6B6,y
         dey
         bpl   -
@hang    bmi   @hang
@s_no64K !raw  "REQUIRES 64K"
@no64Klen=*-@s_no64K

         ; ProRWTS2 has its own function to relocate itself
         !source "src/prorwts2.a"
ProRWTSBuffer
         ; these routines will only be called once, from main memory, before relocating to language card
         !source "src/hw.memcheck.a"
         !source "src/hw.joystick.a"
         !source "src/hw.normfast.a"
*=ProRWTSBuffer+512                  ; ProRWTS needs a 512-byte buffer for its init function
                                     ; so we reuse as much of the 1-time code as possible
                                     ; and fill the rest with zeros
OneTimeSetup
         lda   MachineStatus
         sta   oldstatus
         jsr   SaveScreenHoles       ; save initial copy of screen hole content
         lda   #$91
         sta   holepatch             ; enable restoring of copy from now on
         lda   hddopendir+1          ; save current directory as 'root'
         ldy   hddopendir+3
         +STAY gRootDirectory

         jsr   LoadFile              ; load preferences file into $8000
         !word kGlobalPrefsFilename

         jsr   ParseKeyValueList     ; parse contents into OKVS data structure into LC RAM bank
         !word gGlobalPrefsStore
         !word ldrlo2                ; (ldrlo2) points to last load address, so $8000
         !byte 16
         +LDAY SRC                   ; (SRC) points to free space after the OKVS data structure we just created
         +STAY gGamesListStore       ; save pointer to free space for next store

         jsr   LoadFile              ; load games list file into $8000
         !word kGameListConfFile
         jsr   ParseGamesList        ; parse games list into OKVS data structure in LC RAM bank
         !word gGamesListStore
         !word ldrlo2                ; (ldrlo2) points to last load address, so $8000

         bit   $C010                 ; clear keyboard strobe so we don't mistakenly think we just tried to run something

         jmp   Main                  ; continue execution from LC RAM bank

kGameListConfFile
         !byte 10
         !text "GAMES.CONF"
