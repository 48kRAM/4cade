;license:MIT
;(c) 2019-2020 by 4am
;
!cpu 6502
!to "build/FX/DHGR.SOFT.DIAG",plain
*=$6000

y   = $EF
src = $F0
dst = $F2
row = $FD
col = $FE
counter = $FF

!macro SET_HGR_HI_WITH_OFFSET .offset {
!if .offset > 0 {
         adc   #(.offset*4)
}
         sta   src+1
         eor   #$60
         sta   dst+1
}

!macro RESET_HGR_HI_WITH_OFFSET .offset {
         txa
         +SET_HGR_HI_WITH_OFFSET .offset
}

!macro COPY_WITH_MASK .copymask {
         lda   (src), y
         eor   (dst), y              ; merge source and destination bits
         and   #.copymask            ; isolate the bits to replace, zero the rest
         eor   (dst), y              ; unmerge source and destination bits, leaves 'to keep' destination bits intact
         sta   (dst), y              ; write the result
}

; note: .copymask is an immediate value, not an indexed array or a memory address
!macro COPY_WITH_OFFSET_AND_MASK .offset, .copymask {
         +RESET_HGR_HI_WITH_OFFSET .offset
         +COPY_WITH_MASK .copymask
}

!macro COPY_BYTE .offset {
         +RESET_HGR_HI_WITH_OFFSET .offset
         lda   (src), y
         sta   (dst), y
}

         !source "src/fx/macros.a"
         !source "src/fx/fx.dhgr.common.a"

         lda   #<switchtoaux
         sta   jmpa+1
         sta   jmpb+1
         sta   jmpc+1
         sta   jmpd+1
         sta   jmpe+1
         sta   jmpf+1
         lda   #>switchtoaux
         sta   jmpa+2
         sta   jmpb+2
         sta   jmpc+2
         sta   jmpd+2
         sta   jmpe+2
         sta   jmpf+2
         lda   #<switchtomain
         sta   jmpg+1
         sta   jmph+1
         sta   jmpi+1
         sta   jmpj+1
         sta   jmpk+1
         sta   jmpl+1
         lda   #>switchtomain
         sta   jmpg+2
         sta   jmph+2
         sta   jmpi+2
         sta   jmpj+2
         sta   jmpk+2
         sta   jmpl+2

         +COPY_TO_AUXMEM $60, $08

         lda   #(40+24+7-1) ; columns + rows + blocks per row - 1
         sta   counter

         lda   #39
         sta   col
ColLoop
         lda   #23
         sta   row
         ldy   col
         sty   y
RowLoop
         ldx   row
         lda   hgrrowlo, x
         sta   src
         sta   dst
         lda   hgrrowhi, x
         tax                         ; X = high byte of src throughout RowLoop
         ldy   y
         cpy   #40
         bcc   +
jmpa     jmp   switchtoaux
+
         +SET_HGR_HI_WITH_OFFSET 3
         +COPY_WITH_MASK %10000001
         +COPY_WITH_OFFSET_AND_MASK 4, %10000001
block2
         iny
         cpy   #40
         bcc   +
jmpb     jmp   switchtoaux
+
         +COPY_WITH_OFFSET_AND_MASK 2, %10000110
         +COPY_WITH_OFFSET_AND_MASK 3, %10000001
         +COPY_WITH_OFFSET_AND_MASK 4, %10000001
         +COPY_WITH_OFFSET_AND_MASK 5, %10010110
block3
         iny
         cpy   #40
         bcc   +
jmpc     jmp   switchtoaux
+
         +COPY_WITH_OFFSET_AND_MASK 2, %10000111
         +COPY_WITH_OFFSET_AND_MASK 3, %10000111
         +COPY_WITH_OFFSET_AND_MASK 4, %10000111
         +COPY_WITH_OFFSET_AND_MASK 5, %10000111
block4
         iny
         cpy   #40
         bcc   +
jmpd     jmp   switchtoaux
+
         +LONG_BRANCH_IF_Y_IS_OFFSCREEN switchtoaux
         +COPY_WITH_OFFSET_AND_MASK 1, %10011001
         +COPY_WITH_OFFSET_AND_MASK 2, %10000001
         +COPY_WITH_OFFSET_AND_MASK 3, %10011111
         +COPY_WITH_OFFSET_AND_MASK 4, %10000111
         +COPY_WITH_OFFSET_AND_MASK 5, %10000111
         +COPY_WITH_OFFSET_AND_MASK 6, %10011001
block5
         iny
         cpy   #40
         bcc   +
jmpe     jmp   switchtoaux
+
         +LONG_BRANCH_IF_Y_IS_OFFSCREEN switchtoaux
         +COPY_WITH_OFFSET_AND_MASK 1, %10011111
         +COPY_WITH_OFFSET_AND_MASK 2, %10011111
         +COPY_WITH_OFFSET_AND_MASK 3, %10011111
         +COPY_WITH_OFFSET_AND_MASK 4, %10011111
         +COPY_WITH_OFFSET_AND_MASK 5, %10011111
         +COPY_WITH_OFFSET_AND_MASK 6, %10011111
block6
         iny
         cpy   #40
         bcc   +
jmpf     jmp   switchtoaux
+
         +LONG_BRANCH_IF_Y_IS_OFFSCREEN switchtoaux
         +COPY_WITH_OFFSET_AND_MASK 0, %11100110
         +COPY_WITH_OFFSET_AND_MASK 1, %10011111
         +COPY_BYTE                 2
         +COPY_WITH_OFFSET_AND_MASK 3, %10011111
         +COPY_BYTE                 4
         +COPY_WITH_OFFSET_AND_MASK 5, %10011111
         +COPY_WITH_OFFSET_AND_MASK 6, %10011111
         +COPY_WITH_OFFSET_AND_MASK 7, %11100110
block7
         iny
         cpy   #40
         bcs   switchtoaux
         +COPY_BYTE 0
         +COPY_BYTE 1
         +COPY_BYTE 2
         +COPY_BYTE 3
         +COPY_BYTE 4
         +COPY_BYTE 5
         +COPY_BYTE 6
         +COPY_BYTE 7
switchtoaux
         sta   $C003
         sta   $C005
         ldy   y
         cpy   #40
         bcc   +
jmpg     jmp   switchtomain
         +COPY_WITH_OFFSET_AND_MASK 3, %11000000
         +COPY_WITH_OFFSET_AND_MASK 4, %11000000
block2_aux
         iny
         cpy   #40
         bcc   +
jmph     jmp   switchtomain
+
         +COPY_WITH_OFFSET_AND_MASK 2, %10110000
         +COPY_WITH_OFFSET_AND_MASK 3, %11000000
         +COPY_WITH_OFFSET_AND_MASK 4, %11000000
         +COPY_WITH_OFFSET_AND_MASK 5, %10110000
block3_aux
         iny
         cpy   #40
         bcc   +
jmpi     jmp   switchtomain
+
         +COPY_WITH_OFFSET_AND_MASK 2, %11110000
         +COPY_WITH_OFFSET_AND_MASK 3, %11110000
         +COPY_WITH_OFFSET_AND_MASK 4, %11110000
         +COPY_WITH_OFFSET_AND_MASK 5, %11110000
block4_aux
         iny
         cpy   #40
         bcc   +
jmpj     jmp   switchtomain
+
         +COPY_WITH_OFFSET_AND_MASK 1, %11001100
         +COPY_WITH_OFFSET_AND_MASK 2, %11110000
         +COPY_WITH_OFFSET_AND_MASK 3, %11111100
         +COPY_WITH_OFFSET_AND_MASK 4, %11110000
         +COPY_WITH_OFFSET_AND_MASK 5, %11110000
         +COPY_WITH_OFFSET_AND_MASK 6, %11001100
block5_aux
         iny
         cpy   #40
         bcc   +
jmpk     jmp   switchtomain
+
         +COPY_WITH_OFFSET_AND_MASK 1, %11111100
         +COPY_WITH_OFFSET_AND_MASK 2, %11111100
         +COPY_WITH_OFFSET_AND_MASK 3, %11111100
         +COPY_WITH_OFFSET_AND_MASK 4, %11111100
         +COPY_WITH_OFFSET_AND_MASK 5, %11111100
         +COPY_WITH_OFFSET_AND_MASK 6, %11111100
block6_aux
         iny
         cpy   #40
         bcc   +
jmpl     jmp   switchtomain
+
         +COPY_WITH_OFFSET_AND_MASK 0, %10110011
         +COPY_WITH_OFFSET_AND_MASK 1, %11111100
         +COPY_BYTE                 2
         +COPY_WITH_OFFSET_AND_MASK 3, %11111100
         +COPY_BYTE                 4
         +COPY_WITH_OFFSET_AND_MASK 5, %11111100
         +COPY_WITH_OFFSET_AND_MASK 6, %11111100
         +COPY_WITH_OFFSET_AND_MASK 7, %10110011
block7_aux
         cpy   #40
         bcs   switchtomain
         +COPY_BYTE 0
         +COPY_BYTE 1
         +COPY_BYTE 2
         +COPY_BYTE 3
         +COPY_BYTE 4
         +COPY_BYTE 5
         +COPY_BYTE 6
         +COPY_BYTE 7
switchtomain
         sta   $C002
         sta   $C004
         inc   y
         dec   row
         +LBPL RowLoop
         dec   col
         bne   +
         clc
         !byte $A9
-        sec
         lda   #<block2
         sta   jmpa+1
         lda   #<block3
         sta   jmpb+1
         lda   #<block4
         sta   jmpc+1
         lda   #<block5
         sta   jmpd+1
         lda   #<block6
         sta   jmpe+1
         lda   #<block7
         sta   jmpf+1
         lda   #>block2
         sta   jmpa+2
!if >block3 != >block2 {
         lda   #>block3
}
         sta   jmpb+2
!if >block4 != >block3 {
         lda   #>block4
}
         sta   jmpc+2
!if >block5 != >block4 {
         lda   #>block5
}
         sta   jmpd+2
!if >block6 != >block5 {
         lda   #>block6
}
         sta   jmpe+2
!if >block7 != >block6 {
         lda   #>block7
}
         sta   jmpf+2
         lda   #<block2_aux
         sta   jmpg+1
         lda   #<block3_aux
         sta   jmph+1
         lda   #<block4_aux
         sta   jmpi+1
         lda   #<block5_aux
         sta   jmpj+1
         lda   #<block6_aux
         sta   jmpk+1
         lda   #<block7_aux
         sta   jmpl+1
         lda   #>block2_aux
         sta   jmpg+2
!if >block3_aux != block2_aux {
         lda   #>block3_aux
}
         sta   jmph+2
!if >block4_aux != block3_aux {
         lda   #>block4_aux
}
         sta   jmpi+2
!if >block5_aux != block4_aux {
         lda   #>block5_aux
}
         sta   jmpj+2
!if >block6_aux != block5_aux {
         lda   #>block6_aux
}
         sta   jmpk+2
!if >block7_aux != block6_aux {
         lda   #>block7_aux
}
         sta   jmpl+2
         sta   $C005
         bcc   -
         sta   $C004
+        lda   $c000
         bmi   exit
         dec   counter
         +LBNE ColLoop
exit     rts

; next table can not cross a page boundary
!if <* > $E8 {
         !align 255, 0
}
hgrrowlo
         !byte $00,$80,$00,$80,$00,$80,$00,$80
         !byte $28,$A8,$28,$A8,$28,$A8,$28,$A8
         !byte $50,$D0,$50,$D0,$50,$D0,$50,$D0

; next table can not cross a page boundary
!if <* > $E8 {
         !align 255, 0
}
hgrrowhi
         !byte $40,$40,$41,$41,$42,$42,$43,$43
         !byte $40,$40,$41,$41,$42,$42,$43,$43
         !byte $40,$40,$41,$41,$42,$42,$43,$43

!if * > $6800 {
         !error "Code too large, adjust COPY_TO_AUXMEM macro"
}
