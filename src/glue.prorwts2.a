;license:MIT
;(c) 2018 by 4am & qkumba
;
; ProRWTS2 glue functions
;
; Public functions
; - LoadFile
; - LoadDHRFile
;

gRootDirectory
         !word $FDFD
gPrefix
         !word $FDFD

;------------------------------------------------------------------------------
; LoadFile
; load a file into memory all at once, using ProRWTS2
; supports files in subdirectories, delimited by '/' like ProDOS
; uses file's load address
;
; in:    stack contains 2 bytes of parameters:
;        +1 address of filename
; out:   all flags clobbered
;        all registers clobbered
;        stack set to next instruction after parameters
;------------------------------------------------------------------------------
LoadFile
         +PARAMS_ON_STACK 2
         +LDPARAM 1
         +STAY namlo                 ; set filename
         +STAY gPrefix               ; remember path

         jsr   traverse              ; go to subdirectory, set up filename for read

         lda   #cmdread              ; read (instead of write)
         sta   reqcmd
         lda   #0                    ; 0 = read into main memory
         sta   auxreq
         lda   #$FF                  ; read entire file (ProRWTS2 will figure out exact size)
         sta   sizehi
         jmp   hddopendir            ; exit via ProRWTS2

;------------------------------------------------------------------------------
; LoadDHRFile
; load .A2FC file (uncompressed double hi-res graphics) into memory
; all at once, using ProRWTS2
; first $2000 bytes of file are loaded into auxiliary memory $2000..$3FFF
; second $2000 bytes of file are loaded into main memory $2000..$3FFF
;
; in:    stack contains 2 bytes of parameters:
;        +1 address of filename
; out:   all flags clobbered
;        all registers clobbered
;        stack set to next instruction after parameters
;------------------------------------------------------------------------------
LoadDHRFile
         +PARAMS_ON_STACK 2
         +LDPARAM 1
         +STAY namlo                 ; set filename

         jsr   traverse              ; go to subdirectory, set up filename for read

         lda   #$00                  ; read first $2000 bytes
         sta   sizelo
         lda   #$20
         sta   sizehi
         lda   #1                    ; 1 = read into aux memory
         sta   auxreq
         lda   #cmdread              ; read (instead of write)
         sta   reqcmd
         jsr   hddopendir            ; call ProRWTS2
         lda   #$20                  ; read next $2000 bytes
         sta   sizehi
         dec   auxreq                ; 0 = read into main memory
         jmp   hddrdwrpart           ; call ProRWTS2

traverse
         +LDAY gRootDirectory
         sta   @myreadblock+1
         sty   @myreadblock+3        ; reset 'root' directory (saved at program start)

         ;search for '/' character in filename

         ldx   #0
         ldy   #0
         lda   (namlo), y
         tay
-        inx
         dey
         bmi   @go                   ; no '/', just do the read
         lda   (namlo), y
         cmp   #'/'
         bne   -
         sty   sizelo
         txa
         pha

@myreadblock
@myx80_parms
         ldx   #2
         lda   #0
         jsr   hddreaddirsel
         lda   #NAME_LENGTH
         sta   bloklo
         lda   #>(hdddirbuf - 1)
         sta   blokhi

         ;there can be only one page crossed, so we can increment here

@mynextent1
         inc   blokhi
@mynextent
         ldy   #0
         lda   (bloklo), y
         pha
         and   #$0f
         tax
--       iny
         lda   (bloklo), y
         cmp   (namlo), y
         beq   @myfoundname

         ;match failed, move to next directory in this block, if possible

-        pla

@myskiphdr
         clc
         lda   bloklo
         adc   #ENTRY_SIZE
         sta   bloklo
         bcs   @mynextent1
         cmp   #$ff ;4 + ($27 * $0d)
         bne   @mynextent

         ;read next directory block when we reach the end of this block

         lda   hdddirbuf + NEXT_BLOCK_LO
         ldx   hdddirbuf + NEXT_BLOCK_HI
         bcs   +

@myfoundname
         dex
         bne   --

         ;parse path until last directory is seen

         iny
         lda   (namlo), y
         cmp   #'/'
         bne   -
         pla
         and   #$20 ;Volume Directory Header XOR subdirectory
         bne   @myskiphdr
         tya
         eor   #$ff
         adc   sizelo
         sta   sizelo
         clc
         tya
         adc   namlo
         sta   namlo

         ;cache block number of current directory
         ;as starting position for subsequent searches

         ldy   #(KEY_POINTER + 1)
         lda   (bloklo), y
         tax
         dey
         lda   (bloklo), y
         sta   (reloc + unrhddblocklo - unrelochdd) + 1
         stx   (reloc + unrhddblockhi - unrelochdd) + 1
+        sta   @myx80_parms + 1
         stx   @myx80_parms + 3
++       lda   sizelo
         bne   @myreadblock
         tay

         pla
         sta   (namlo), y
@go
         rts

;------------------------------------------------------------------------------
; ProDOS_enter
; intercept certain ProDOS requests
; wrap them to ProRWTS2 file requests
;
; in:    return address+1 is command and pointer to parameter block
; out:   all flags clobbered
;        A=0, X and Y preserved
;        stack set to next instruction after parameters
;
; to do: preserve non-$4x zpage locations for titles that open files after start
;        enable seek
;        enable < 512 bytes reads
;------------------------------------------------------------------------------
packet = $40 ;word
buffer = $42 ;word
ProDOS_enter
    pla
    sta    @fetchaddr+1
    pla
    sta    @fetchaddr+2
    jsr    @fetchbyte
    sta    @request+1
    jsr    @fetchbyte
    sta    packet
    jsr    @fetchbyte
    sta    packet+1
    lda    @fetchaddr+2
    pha
    lda    @fetchaddr+1
    pha
    txa
    pha
    tya
    pha
@request
    lda    #$d1
    cmp    #$c7
    beq    @do_prefix
    cmp    #$c8
    beq    @do_open
    cmp    #$ca
    beq    @do_read
    cmp    #$cb
    beq    @do_write
    cmp    #$cc
    beq    @do_close
;;    cmp    #$ce
;;    beq    @do_seek
    ;;any others??
    jmp    ProDOS_fatal
@do_prefix
    jsr    @imp_prefix
    jmp    ProDOS_exit
@do_open
    jsr    @imp_open
    jmp    ProDOS_exit
@do_read
    jsr    @imp_read
    jmp    ProDOS_exit
@do_write
    jsr    @imp_write
    jmp    ProDOS_exit
@do_close
    jsr    @imp_close
    jmp    ProDOS_exit
;;@do_seek
;;    jsr    @imp_seek
;;    jmp    ProDOS_exit


PREV_BLOCK_LO = $0      ;ProDOS constant
PREV_BLOCK_HI = $1      ;ProDOS constant
@imp_prefix
    ldx    #buffer
    jsr    @setbuffer1
    lda    gPrefix
    sta    packet
    lda    gPrefix+1
    sta    packet+1
    ldy    #0
    lda    (packet), y
    tax
    inx
    !byte  $2c
@copy_prefix
    lda    (packet), y
    iny
    iny
    iny
    cmp    #$2e
    bcs    @skip_slash1
    lda    #'/'
@skip_slash1
    sta    (buffer), y
    bcs    @skip_slash2
    tya
    ldy    #0
    sta    (buffer), y
    tay
@skip_slash2
    dey
    dey
    dex
    bne    @copy_prefix
    ldy    #1
    lda    #'/'
    sta    (buffer), y
    iny
    lda    #'X'
    sta    (buffer), y
    rts

@imp_open
    ldx    #namlo
    jsr    @setbuffer1
    iny
    inc    @handles+1
@handles
    ldx    #0
    iny
    lda    (packet), y
    sta    @handle-1, x
    iny
    txa
    sta    (packet), y
    rts

@imp_read
    lda    #cmdread
    !byte  $2c
@imp_write
    lda    #cmdwrite
    sta    reqcmd
    jsr    @set_rdwrbuff
    jmp    hddopendir

@imp_close
    dec    @handles+1
    bne    @close_ret
    lda    #$b1
    sta    overridepatch1
    sta    overridepatch2
    lda    #bloklo
    sta    overridepatch1+1
    sta    overridepatch2+1
    lda    #>hdddirbuf

@patch_buffer
    sta    bufferpatch2+2
    sta    bufferpatch3+2
    sta    bufferpatch4+2
    sta    bufferpatch6+1
    sta    bufferpatch7+2
    sta    bufferpatch9+2
    sta    bufferpatch10+1
    tax
    inx
    stx    bufferpatch5+2
    stx    bufferpatch8+2
    dex
    dex
    stx    bufferpatch1+1
@close_ret
    rts

@fetchbyte
    inc    @fetchaddr+1
    bne    @fetchaddr
    lda    @fetchaddr+2
@fetchaddr
    lda    $d1d1
    rts

@set_rdwrbuff
    ldy    #1
    lda    (packet), y
    tax
    lda    @handle-1,x
    jsr    @patch_buffer
    lda    #$a9
    sta    overridepatch1
    sta    overridepatch2
    iny
    lda    (packet), y
    sta    overridepatch1+1
    iny
    lda    (packet), y
    sta    overridepatch2+1
    ldx    #sizelo
    iny
    !byte  $2c
@setbuffer1
    ldy    #1

@setbuffer
    lda    (packet), y
    sta    $0,x
    iny
    lda    (packet), y
    sta    $1,x
    rts

@handle
    !byte  0, 0 ;only up to two handles at a time
